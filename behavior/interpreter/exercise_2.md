#### Задание 2. Реализовать иерархию классов, которая определяет следующую грамматику строкового выражения:
```angular2html
<expr> 	::= 	<concat> | <if> | <loop> | <str>
<concat> 	::= 	<expr><expr> | <concat><expr>
<if> 	::= 	(var?<expr>:<expr>)
<loop> 	::= 	(var:<expr>)
<str> 	::= 	<строка без символов «(», «)», «?», «:»>
<var> 	::= 	<имя целочисленной переменной>
```

#### Выражение concat возвращает конкатенацию нескольких выражений expr (двух или более); выражение if анализирует значение переменной var, и если var ≠ 0, то возвращает первое из указанных выражений expr, в противном случае возвращает второе из указанных выражений; выражение loop возвращает выражение expr, повторенное столько раз, каково значение переменной var (или пустую строку, если var ≤ 0).

#### Иерархия классов содержит абстрактный класс AbstractExpression, классы NontermConcat, NontermIf и NontermLoop, определяющие нетерминальные выражения concat, if, loop соответственно, и класс TermStr, определяющий терминальное выражение str. Класс AbstractExpression содержит два абстрактных метода InterpretA(ct) и InterpretB(ct), возвращающих строковое значение и определяющих два варианта интерпретации выражения (параметр-ссылка ct имеет тип Context, описываемый далее). В каждом конкретном классе (NontermConcat, NontermIf, NontermLoop и TermStr) требуется переопределить эти абстрактные методы.

• Интерпретация A состоит в восстановлении строкового представления выражения, удовлетворяющего приведенной выше грамматике, по его синтаксическому дереву разбора; при этом имена переменных берутся из контекста (экземпляра класса Context).

• Интерпретация B состоит в построении конкретной строки по выражению, представленному синтаксическим деревом разбора; при этом значения переменных также берутся из контекста.

#### Примеры интерпретаций A и B для одного и того же синтаксического дерева разбора: строка «abc(var1?(n:x):dd)yz» и строка «abcxxxxyz» (при условии, что контекст содержит переменные var1 = 1 и n = 4).

#### Класс Context содержит два набора элементов размера 10: строковый набор names с именами доступных переменных и набор целых чисел values со значениями соответствующих переменных (для хранения наборов можно использовать массивы или другие структуры данных). Конструктор класса Context не имеет параметров; он заносит в набор names односимвольные имена переменных от «a» до «j» (в алфавитном порядке), а в набор values — нулевые значения. Класс Context включает три метода: SetVar(ind, name, value), GetName(ind), GetValue(ind). Параметр ind во всех методах определяет индекс обрабатываемой переменной (число от 0 до 9). Метод SetVar задает для переменной с индексом ind имя (строку name) и значение (целое число value). Метод GetName возвращает имя переменной с индексом ind, метод GetValue возвращает значение переменной с индексом ind. При реализации этих методов можно не проверять допустимость значений параметра ind, а также не контролировать возможную ошибочную ситуацию, когда два элемента набора names совпадают (т. е. когда две разные переменные имеют одинаковые имена).

#### Класс NontermConcat содержит структуру данных exprs (например, массив) с элементами-ссылками типа AbstractExpression, которая инициализируется в конструкторе, имеющем соответствующий параметр-структуру. Можно считать, что выражение concat содержит не более 5 выражений expr.

#### Класс NontermIf содержит поля expr1 и expr2 — ссылки на объекты AbstractExpression (первое и второе выражение expr в правой части определения выражения if) — и целочисленное поле ind (индекс переменной var в некотором объекте-контексте). Класс NontermLoop содержит поле expr — ссылку на объект AbstractExpression (выражение expr в правой части определения выражения loop) — и целочисленное поле ind (индекс переменной var в некотором объекте-контексте). Значения полей классов NontermIf и NontermLoop задаются в их конструкторах с помощью одноименных параметров.

#### Класс TermStr содержит строковое поле s, задаваемое в конструкторе с помощью строкового параметра. В методах InterpretA и InterpretB этого класса должно возвращаться значение поля s без каких-либо изменений.

#### Тестирование разработанной системы классов. Дано целое число N (≤ 30) и N наборов значений, каждый из которых определяет один узел синтаксического дерева разбора. Последующие узлы могут содержать ссылки на предыдущие, поэтому все узлы следует сохранять в коллекции nodes (например, массиве) с элементами-ссылками типа AbstractExpression. Каждый набор, соответствующий узлу синтаксического дерева, начинается с символа «C», «I», «L» или «S». Объекту класса NontermConcat соответствует символ «C», за которым следует целое число K (2 ≤ K ≤ 5) и K индексов узлов из уже заполненной части коллекции nodes (индексирование элементов коллекции nodes ведется от 0); все узлы в указанном порядке должны входить в структуру exprs объекта NontermConcat. Объекту класса NontermIf соответствует символ «I», за которым следует индекс V переменной в некотором контексте (целое число в диапазоне от 0 до 9) и индексы двух узлов из уже заполненной части коллекции nodes. Объекту класса NontermLoop соответствует символ «L», за которым следует индекс V переменной в некотором контексте и индекс некоторого узла из уже заполненной части коллекции nodes. Наконец, объекту класса TermStr соответствует символ «S», за которым следует строка — значение выражения str.

#### Также даны три набора значений, определяющих три различных контекста. Определение каждого контекста содержит целое число M (≤ 10) и M наборов троек (ind, name, val), в которых ind определяет индекс переменной в контексте, name определяет имя переменной, а val — ее значение (для остальных переменных контекста сохраняются имена и значения по умолчанию).

#### Используя исходные данные, сформировать элементы синтаксического дерева разбора и сохранить их в коллекции nodes, а также создать и настроить три объекта типа Context. Для последнего элемента коллекции nodes вызвать методы InterpretA и InterpretB, указав в качестве параметра каждый из созданных контекстов, и вывести их возвращаемые значения (вначале выводятся значения, соответствующие первому контексту, затем второму, затем третьему). 