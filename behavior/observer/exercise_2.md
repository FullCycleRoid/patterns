#### Задание 2. Реализовать вариант взаимодействия субъектов и наблюдателей, не требующий специальных методов доступа к состоянию субъекта и упрощающий взаимодействие наблюдателя с несколькими субъектами.

#### При таком варианте взаимодействия наблюдатель сразу получает значение нового состояния субъекта и поэтому наблюдателю не требуется обращаться к субъекту за получением дополнительной информации. Подобная модель взаимодействия называется моделью проталкивания (push model).

#### Первая иерархия классов включает базовый класс Subject с конкретными методами Attach(observ), Detach(observ), Notify(info) и класс-потомок ConcreteSubject. Методы Attach и Detach имеют параметр-ссылку типа Observer и не возвращают значений. Метод Notify имеет строковый параметр, не возвращает значения и является защищенным. В классе Subject дополнительно описать поле observers — структуру данных с элементами-ссылками типа Observer, в которой хранятся все наблюдатели, присоединенные в настоящий момент к субъекту (можно считать, что наблюдателей не более 10). В качестве такой структуры удобно использовать динамическую структуру, имеющую команды для добавления и удаления элементов.

#### Метод Attach(observ) добавляет объект observ в структуру observers, метод Detach(observ) удаляет объект observ из данной структуры. В методе Notify(info) выполняется перебор элементов структуры observers и для каждого элемента этой структуры вызывается его метод OnInfo(sender, info), причем в качестве параметра info указывается параметр метода Notify, а в качестве параметра sender — ссылка на объект Subject, вызвавший метод Notify. Таким образом, наблюдатель сразу информируется и о наступившем событии, получая информацию в параметре info, и о субъекте sender, который инициировал это событие. При реализации метода Notify необходимо учесть ситуацию, когда некоторые наблюдатели в своем методе OnInfo отсоединятся от субъекта, что приведет к изменению структуры данных observers.

#### В классе ConcreteSubject описать поле state, которое имеет строковый тип и моделирует текущее состояние субъекта. С ним связан метод SetState(st), имеющий строковый параметр st. Если этот параметр не равен текущему значению поля state, то метод изменяет поле state, присваивая ему значение параметра st, и дополнительно вызывает метод Notify(state); если параметр st совпадает с текущим значением поля state, то метод SetState не выполняет никаких действий. Конструктор класса ConcreteSubject не имеет параметров, поле state инициализируется пустой строкой.

#### Вторая иерархия включает абстрактный класс Observer с абстрактным методом OnInfo(sender, info) и класс-потомок ConcreteObserver. Параметр sender метода OnInfo является ссылкой на объект типа Subject, параметр info — строковый. Класс ConcreteObserver дополнительно имеет строковое поле log и символьное поле detachInfo, а также методы Attach, Detach и GetLog. Конструктор класса ConcreteObserver имеет параметр detachInfo, который инициализирует соответствующее поле; поле log инициализируется пустой строкой. Методы Attach(subj) и Detach(subj) имеют параметр-ссылку типа Subject и не возвращают значений. В методе Attach выполняется вызов метода Attach объекта subj, в методе Detach выполняется вызов метода Detach объекта subj, причем в качестве параметра в обоих вызываемых методах передается ссылка на объект ConcreteObserver, инициировавший вызов этих методов. Метод GetLog не имеет параметров и возвращает значение поля log.

#### Метод OnInfo(sender, info), переопределяемый в классе ConcreteObserver, является основным методом, обеспечивающим взаимодействие между конкретным субъектом и конкретным наблюдателем. Напомним, что этот метод вызывается конкретным субъектом для информирования всех присоединенных к нему в настоящий момент наблюдателей, причем информация передается в поле info, а поле sender содержит ссылку на субъект, передавший эту информацию. В данном задании в методе OnInfo надо выполнить следующие действия: добавить содержимое параметра info в конец строки log объекта ConcreteObserver, для которого был вызван метод OnInfo, и, кроме того, если последний символ строки info совпадает со значением поля detachInfo объекта ConcreteObserver, то необходимо отсоединить этого наблюдателя от субъекта sender, вызвав метод Detach объекта ConcreteObserver с параметром sender.

#### Тестирование разработанной системы классов. Дано целое число N (≤ 10). Кроме того, дано целое число K (≤ 45) и набор двухсимвольных строк, первым символом которых является цифра «1» или «2», а вторым — строчная латинская буква. Создать два объекта subj1 и subj2 типа ConcreteSubject и коллекцию (например, массив) observers из N объектов типа ConcreteObserver, указывая в качестве параметра detachInfo конструктора объектов ConcreteObserver строчные латинские буквы, которые перебираются в алфавитном порядке («a» для первого объекта коллекции observers, «b» для второго объекта и т. д.). Для каждого объекта ConcreteObserver вызвать методы Attach с параметрами-ссылками на объекты subj1 и subj2. Затем для каждой строки из данного набора строк вызвать метод SetState объекта subj1 или subj2, передав эту строку в качестве параметра, причем если строка начинается с цифры «1», то метод SetState должен вызываться для объекта subj1, а если с цифры «2», то для объекта subj2. После обработки всех строк из исходного набора вывести значения полей log объектов из коллекции observers, используя метод GetLog класса ConcreteObserver. Выведенные строки будут содержать все данные, переданные наблюдателям субъектами subj1 и subj2 (без одинаковых соседних данных), вплоть до тех, которые вызвали отсоединение наблюдателя от соответствующего субъекта. 