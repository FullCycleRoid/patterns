#### В данном задании рассматривается вариант иерархии классов обработчиков, в которой базовый класс обеспечивает в методе HandleRequest всю необходимую функциональность для передачи запроса по цепочке обработчиков, а подклассы расширяют эту функциональность. Кроме того, в задании рассматривается вариант представления запросов в виде иерархии классов, инкапсулирующих параметры запроса.

#### Задание 2. Реализовать две иерархии классов, связанные с применением паттерна Chain of Responsibility. Первая иерархия является иерархией классов-запросов и включает абстрактный класс Request и два конкретных класса RequestA и RequestB. Класс Request содержит абстрактный метод ToStr без параметров, возвращающий строковое описание запроса. В классах RequestA и RequestB определено поле param, задающее параметр запроса, причем для класса A параметр является целочисленным, а для класса B — строковым. Поле param инициализируется в конструкторе с помощью одноименного параметра. Также в этих классах определен метод GetParam, который возвращает значение поля param, и метод ToStr, который возвращает описание запроса, включающее тип запроса (букву «A» или «B»), двоеточие и параметр запроса (целое число для запроса A и строку для запроса B), например, «A:12», «B:abc».

#### Вторая иерархия является иерархией классов-обработчиков и включает конкретный базовый класс Handler и классы-потомки HandlerA и HandlerB. Класс Handler содержит поле successor (ссылку на объект Handler) и метод HandleRequest(req) (не возвращает значений, имеет параметр-ссылку req типа Request, определяющий вид запроса). Метод HandleRequest работает следующим образом: если поле successor не является пустой ссылкой, то вызывается метод HandleRequest(req) для объекта successor, в противном случае выводится текст «Request <req> not processed» (запрос <req> не обработан), где <req> — значение, возвращаемое методом ToStr параметра req. Класс Handler имеет конструктор с параметром-ссылкой successor типа Handler, который инициализирует одноименное поле. Таким образом, данный класс обеспечивает всю необходимую функциональность для организации цепочки обработчиков.

#### Классы HandlerA и HandlerB предназначены для обработки запросов соответствующего типа (A или B) и имеют целочисленное поле id (идентификатор обработчика) и поля param1 и param2 (определяют диапазон параметров запросов, которые может обработать данный обработчик). Тип полей param1 и param2 соответствует типу параметра обрабатываемого запроса: для класса HandlerA это целый тип, для класса HandlerB — строковый. Конструктор классов HandlerA и HandlerB имеет четыре параметра: successor типа ссылки на Handler, id целого типа, param1 и param2 типа, соответствующего типу одноименных полей. В конструкторе вызывается конструктор базового класса с параметром successor и инициализируются поля id, param1 и param2.

#### Метод HandleRequest(req) классов HandlerA и HandlerB выполняет следующие действия:

• вначале проверяется тип времени выполнения параметра req, и в случае, если этот тип соответствует типу обрабатываемого запроса (RequestA для HandlerA, RequestB для HandlerB), проверяется, лежит ли параметр param запроса req в диапазоне от param1 до param2, включая граничные значения param1 и param2 (строковые параметры для запроса RequestB сравниваются лексикографически);

• eсли обе проверки являются успешными, то запрос обрабатывается путем вывода текста «Request <req> processed by handler <id>» (запрос <req> обработан обработчиком <id>), где <req> — значение, возвращаемое методом ToStr объекта req, а <id> — значение поля id обработчика;

• в противном случае выполняется вызов метода HandleRequest(req) базового класса (в котором либо происходит переход к следующему обработчику в цепочке, либо, при его отсутствии, выводится сообщение о невозможности обработать запрос).

#### Вспомогательный класс Client содержит поле h — ссылку типа Handler на обработчик, являющийся первым в ранее сформированной цепочке обработчиков. Поле h инициализируется в конструкторе с помощью одноименного параметра. Класс Client также содержит метод SendRequest(req), имеющий параметр-ссылку типа Request и не возвращающий значения; в этом методе выполняется вызов метода HandleRequest(req) для объекта h.

#### Тестирование разработанной системы классов. Дано целое число N (≤ 10) и набор из N троек элементов. В каждой тройке первый элемент является символом «A» или «B», а тип остальных двух элементов p1, p2 зависит от символа: в случае символа «A» это целые числа, а в случае «B» — строки. В любом случае выполняется неравенство p1 ≤ p2, где для чисел используется обычное сравнение, а для строк — лексикографическое. Используя переменную h — ссылку на объект Handler, последовательно создать один объект типа Handler (передав ему в качестве параметра пустую ссылку) и N объектов типа HandlerA или HandlerB (тип определяется первым элементом соответствующей тройки). Ссылки на создаваемые объекты записываются в одну и ту же переменную h; параметрами конструктора для объектов HandlerA и HandlerB должны быть значения h, i, p1, p2, где i — индекс очередной тройки из исходного набора (тройки индексируются от 0), а p1 и p2 — второй и третий элемент этой тройки. В результате будет создана цепочка из N + 1 обработчика, причем первым элементом этой цепочки (ссылка на который будет храниться в переменной h) будет обработчик типа HandlerA или HandlerB с идентификатором N − 1, предпоследним — обработчик типа HandlerA или HandlerB с идентификатором 0, а последним — обработчик типа Handler (не имеющий идентификатора). Создать объект cli типа Client, указав в качестве параметра его конструктора значение ссылки h.

#### Также дано целое число K (≤ 20) и набор из K различных запросов, определяемых парами элементов (c, p), где c — символ «A» или «B», а p — параметр запроса (целочисленный в случае «A», строковый в случае «B»). Для каждой пары создать запрос req соответствующего типа и выполнить вызов метода SendRequest(req) объекта cli. Выводить какие-либо результаты не требуется, так как вывод осуществляется в методах HandleRequest объектов-обработчиков. 